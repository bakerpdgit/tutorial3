# Inheritance and Polymorphism

## Exercise 3 (example)

In *object-oriented programming*, polymorphism is implemented using **inheritance**. When class $A$ inherits from class $B$, class $A$ automatically contains all the **public and protected** methods/attributes from class $B$, and it is free to define its own attributes/methods as well. In this case, class $A$ is called the **subclass** and class $B$ is called the **superclass**.

The *protected specifier* allows attributes/methods to be **not externally accessible** but still accessible within the same class or its subclasses. Since normally attributes are private, subclasses **do not get access** to the attributes of the superclass. Protected offers a solution to this problem.

There are a few benefits of the *object-oriented* approach to polymorphism:

1. Similar attributes, method signatures and code across subclasses can now be implemented in the **superclass** and inherited - reducing code duplication.
2. We now can assign **data type** to all of the subclasses.

Inheritance is often thought of as a **is a** relationship. For example if `Dog` inherits from `Mammal`, we say that `Dog` **is a** `Mammal`, which makes sense. This allows us to use the `Mammal` type annotation for `Dog`. Previously if we had a *list* of either dogs, cats or horses, we would have to use the type annotation `list[Dog | Cat | Horse]`. With **inheritance**, we can use the type annotation `list[Mammal]` instead. 

In contrast, composition is often thought of as a **has a** relationship, e.g. a `Car` has an `Engine`.

However, for us to assign the `Animal` data type to instances of `Dog`, `Cat`, or `Horse`, the `Animal` class **must** define the `speak()` method - in this case, we use `pass` to skip the implementation as it is defined separately for each subclass. This phenomenon is called **method overriding** - when a subclass *redefines* a method already defined in the superclass, leading to possibly **different behaviours** when the same method is called on the superclass and subclass.

The method in the superclass that is *being overrided* is known as a **virtual method** - a method that can be overrided through inheritance. In Python, **all methods are virtual** so we don't need to specify it, but in other languages there is a `virtual` keyword to specify that a method is virtual.

### Note (beyond A-Level)

The *object-oriented* approach to polymorphism belongs to the **conceptual class** of *subtype polymorphism*.
