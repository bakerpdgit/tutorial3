# Inheritance and Polymorphism

## Exercise 3 (example)

**Polymorphism** as in *Exercise 1* has a few flaws - there are often shared attributes, method signatures and code across classes with the same interface. In addition, we cannot assign a **single concrete type** to all classes - this is less of a problem in Python, but is a serious problem in other langauges where there are **no** union types.

The *object-oriented* solution to this problem is **inheritance** - we can make an *abstracted* **superclass** that all the current classes inherit their public attributes & methods from, hence avoiding the need to repeat code. However, attributes are often *private* and hence **not inherited** from the superclass, so we cannot use them in the subclass. The **protected specifier** solves the problem - protected values are **not accessible externally** but are accessible through inheritance.





**Polymorphism** is when objects of different classes are treated as objects that have a **common superclass**. In other words, a **single method** / function can operate on multiple objects, with objects responding in their own way. E.g. multiple instances of classes that have the same method, but each class's implementation of the method may be completely different.

There are two main types of polymorphism, **runtime polymorphism** and **compile-time polymorphism**.

**Runtime polymorphism** is where multiple objects have the same method that may have different underlying implementations, and which "version" of the method is called is determined by the class of the object dynamically at runtime. The classes of the object could be related through inheritance or could be completely unrelated. In the case that the classes are related through inheritance, this is achieved through **overrriding**, which is when a subclass overrides the inherited method from the parent class.

**Compile-time polymorphism** is called **method overloading**, which is when multiple methods/functions can have the same name, but have different parameters or data types specifying the interface. This is not covered on the A-Level syllabus and is also not directly supported by Python. Instead Python only has **optional parameters** which allows a single method to be called with differing numbers of arguments.
