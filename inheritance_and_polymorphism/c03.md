# Inheritance and Polymorphism

## Exercise 3 (example)

In *object-oriented programming*, polymorphism is implemented using **inheritance**. When class $A$ inherits from class $B$, class $A$ automatically contains all the **public and protected** methods/attributes from class $B$, and it is free to define its own attributes/methods as well. In this case, class $A$ is called the **subclass** and class $B$ is called the **superclass**.

In Python, inheritance is denoted by placing the **superclass** in *brackets* following the subclass' name. `super()` refers to the *instance* of the superclass. Often, the first thing you do in the subclass' constructor is call the superclass' constructor via `super().__init__(<args>)`.

The *protected specifier* allows attributes/methods to be **not externally accessible** but still accessible within the same class or its subclasses. Since normally attributes are private, subclasses **do not get access** to the attributes of the superclass. Protected offers a solution to this problem.

There are a few benefits of the *object-oriented* approach to polymorphism:

1. Similar attributes, method signatures and code across subclasses can now be implemented in the **superclass** and inherited - reducing code duplication.
2. We now can assign a single concrete **data type** to all of the subclasses.

Inheritance is often thought of a "***is a***" relationship, e.g. `Dog` is an `Animal`. Whenever class $A$ inherits from class $B$, we can assign the type $B$ to an instance of class $A$. This is a useful abstraction that allows us to simplify the `list[Dog | Cat | Horse]` type annotation into `list[Animal]`. `Dog` is an `Animal`, so it makes sense to assign the `Animal` type to a dog. In contrast, composition is often thought of as a "***has a***" relationship, e.g. `Car` has an `Engine`.

Since we are assigning the `Animal` type to **instances of different subclasses** and we are using the `speak()` method, we **must** define the `speak()` method in the `Animal` class. However, the implementation for `speak()` is different for each subclass, so we can skip the implementation in the superclass. The phenomenon of a subclass *redefining* a method already defined in the superclass is known as **method overriding**.

The method in the superclass that is *being overrided* is known as a **virtual method** - a method that can be overrided through inheritance. In Python, **all methods are virtual** so we don't need to specify it, but in other languages there is a `virtual` keyword to specify that a method is virtual.

### Note (beyond A-Level)

The *object-oriented* approach to polymorphism belongs to the **conceptual class** of *subtype polymorphism*.
