# Inheritance and Polymorphism

## Exercise 2 (task)

Two unrelated objects sharing the same interface is **not the only kind** of polymorphism - in fact, polymorphism extends beyond OOP; it is a *feature* of a programming language. However, **OOP** provides *a form* of polymorphism that we will see in the next exercise.

Polymorphism can be classified by their **implementation** - whether it is compile-time or run-time. One example of **compile-time polymorphism** is *function overloading* - when functions have the same name and return type, but have different arguments. Python does not support function overloading, but other languages do.

However, Python supports **operator overloading** - the ability to use operators such as `+` and `==` on user-defined objects. This is a form of **run-time polymorphism**, as the specific implementation to use is decided at run-time depending on the object's type. Operator overloading can be achieved through **special methods** - methods beginning and ending with two underscores (`__`). We have seen special methods before - the `__init__` and `__repr__` methods are special. 

In Python, **every operator**, such as `+`, `-`, etc. can be *extended* to user-defined classes via special methods. For example, the `+` operator is overloaded using the `__add__` method, and the `==` operator is overloaded using the `__eq__` method. This allows us to use the `+`, `==` operators on our own classes as well.

For more information, visit [this site](https://www.pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html) to see all the python special methods.

### Task

Fill in the blanks to make `Rectangle` and `Circle` classes both have the `area()` and `perimeter()` methods. In addition, define the `__eq__` special method for both classes, where two classes are considered *equal* if their attributes are equal in any order. E.g. `Rectangle(3, 4)` is the same as `Rectangle(4, 3)`. Note the use of the `isinstance` function, which checks if an object is an instance of a given class.

### More Info (Not in A-Level)

Unrelated objects sharing a common interface, function overloading and operator overloading belong to the **conceptual class** of *ad-hoc polymorphism*. Inheritance-based polymorphism as seen in the next exercise belongs to a **different** conceptual class.

Since polymorphism is very *broad*, when we refer to polymorphism in OOP, we refer to **inheritance-based** polymorphism, as it is how **OOP** provides polymorphism. Although polymorphism as seen in *Exercise 1* is allowed in Python, it is **not strictly OOP**, as it uses *union types* (types separated by a bar `|`), which is not an OOP feature.

