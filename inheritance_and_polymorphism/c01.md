# Inheritance and Polymorphism

## Exercise 1 (example)

Due to the principle of *encapsulation* in OOP, **every class** has an *interface* - the public methods that a class exposes. Recall that we **only need** the class' *interface* to be able to **use its objects** externally.

This has one important consequence - objects of different *types* can have the same **method** or even the same *interface*. This is referred to as **polymorphism** - the ability to access objects of different types through the same interface, i.e. using objects of different types in the same way.

In Python, it is *not necessary* that polymorphic methods have the **same return type and arguments in all classes**, but it is good practice to have the same arguments and return types - more consistent for external users to work with. The *method name*, *arguments* and *return type* form the **signature** of that method.

For example, if `Dog`, `Cat` and `Horse` all have a `speak()` method, and we have a *list* of objects that are either a `Dog`, `Cat` or `Horse`, we can safely call `.speak()` on every object in the list.
