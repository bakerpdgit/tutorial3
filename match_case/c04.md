# Match... case... statements

## Exercise 4 (task)

Let's focus on the following example in the previous exercise:
```python
animals = ["lion", "monkey", "crocodile", "bird", "leopard"]
match animals:
    case [first, *rest]:
        print(f"The {first} is king of the jungle, in charge of the other animals: {', '.join(rest)}")
    case []:
        print("There are no animals left!")
```

The example makes use of a very fundamental fact about lists: every list is either empty, or a first element followed by
a list of other elements. We call the first element the *head* and the list of other elements the *tail*. Note that the
tail can be empty.

What's special about the head-tail decomposition is that if we apply it repeatedly to any list, we eventually reach the
empty list. This means that `match` statements like the one above that handle the head-tail case and the empty list case
can be used to write recursive functions. For instance:

```python
def sum(lst):
    match lst:
        case [first, *rest]:
            return first + sum(rest)
        case []:
            return 0
```

The base case of the recursion is for the empty list. The recursive case divides the list into a head and tail, and
recurses on the tail. This gives the full definition of the function in terms of two simple cases.

Write the functions `product` and `reverse` recursively with `match... case...`, by recursing on the tail in the case
and using the empty list as the base case. `product` should return the result of multiplying together all the elements,
and `reverse` should reverse a list out-of-place, returning a new one without changing the original.

For `product`, you will have to think about what value to assign `product([])` that means the single-element lists can
be treated exactly the same as longer lists.
