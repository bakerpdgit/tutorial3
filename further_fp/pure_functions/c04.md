# Pure functions

## Exercise 4 (example)

We now address some complications which make writing pure functions more difficult. For various reasons, these
complications will eventually become moot, so feel free to skip this example and the following task.

As in the case of `pure_function_3` in exercise 2, it may be a certain function updates global state, but its return
value is used directly in an expression. To purify such a function we need to extract the return value from the tuple
into a variable, and use that variable in the expression

> I consider it bad style anyway to update global state and pass the return value into another function. If you must
> use an impure function, at least don't hide it in an expression. In the extreme case, consider
> `print("Foo") and print("Bar")`, which unintuitively prints only "Foo" as `print` returns `None` which is treated as
> `False`, short-circuiting the `and`.

It may be that an impure function modifies a mutable object, which could be passed as an argument or read from global
state. The pure version must copy the object (`copy.deepcopy`) before making local changes, and return its copy.
(Performance and memory use are not concerns; we trust the compiler to optimise away any inefficiencies this causes.)

It may be that the side effects of a function come not from its own body, but from another function it calls. Hidden
inputs to the inner function also become hidden inputs to the caller. We will need to pass state all the way down the
call stack and all the way back up.
